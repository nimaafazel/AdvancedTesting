using System;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Stock;
using Microsoft.QualityTools.Testing.Fakes;

namespace StockTests
{
    [TestClass]
    public class StockStubTest
    {
        /// <summary>
        /// This method will run against a Fake Stub created by Microsoft Fakes, so we don't need to make a special class for testing purpouses.
        /// </summary>
        [TestMethod]
        public void TestContosoStockPrice()
        {
            // Arrange
            // create the Fake stockFeed to implement the Interface and inject it to StockAnalyzer
            IStockFeed stockFeed = new Stock.Fakes.StubIStockFeed()  // Generated by Fakes.
            {
                // Define each method:
                // Name is original name + parameter types:
                GetSharePriceString = (company) => { return 1234; }  // we are returning a fixed price to make the test pass.
            };

            // In the completed application, stockFeed would be a real one:
            var componentUnderTest = new StockAnalyzer(stockFeed);

            // Act
            int actualValue = componentUnderTest.getContosoPrice();

            // Assert
            Assert.AreEqual(1234, actualValue);
        }

        /// <summary>
        /// This method will test the correct name of the stock.
        /// It uses a Stub implementing the IStockFeed to simulate the real class StockFeed.
        /// </summary>
        [TestMethod]
        public void TestVariableContosoPrice()
        {
            // Arrange
            int priceToReturn;
            string companyCodeUsed = "";

            // set the price that will be returned by the stub
            priceToReturn = 345;

            var componentUnderTest = new StockAnalyzer(new Stock.Fakes.StubIStockFeed()
            {
                GetSharePriceString = (company) =>
                {
                    // store the parameter value
                    companyCodeUsed = company;

                    // return the value prescribed by this test:
                    return priceToReturn;
                }
            });

            // Act
            int actualResult = componentUnderTest.getContosoPrice(); // we'll get 345 because we are using the same variable 

            // Assert
            // verify the correct result in the usual way
            Assert.AreEqual(priceToReturn, actualResult); // this will pass

            // verify that the component made the correct call
            Assert.AreEqual("COOO", companyCodeUsed);  // this will also pass because we have harcoded COOO on the comparator
        }

        /// <summary>
        /// Test method with Shims on a DateTime method.
        /// Since DateTime is part of the System library, we add the Fakes to its reference.
        /// </summary>
        [TestMethod]
        public void TestCurrentYear()
        {            
            int fixedYear = 2000;  // a fixed year

            // to use Shims, we need to use them in a ShimContext.
            // we encapsulate the context in a "using" statement, so that when the test finishes, the Shim frees up the method and everything goes back
            // to normal on subsequent tests.
            using (ShimsContext.Create())
            {
                // Arrange
                // Shim DateTime.Now to return a fixed date
                System.Fakes.ShimDateTime.NowGet = () => 
                { return new DateTime(fixedYear, 1, 1); /* january 1st 2000 */ };

                // Instantiate the component under test:
                var componentUnderTest = new SimpleClass();

                // Act
                int year = componentUnderTest.getCurrentYear();  // call the method normally, but since we ar inside the Shim, the DateTime.Now will always return 2000

                // Assert 
                Assert.AreEqual(fixedYear, year);  // this will always pass because we have used the Shim with a fixed year of 2000
            }
        }
    }
}
